import { sqliteTable, text, integer, real } from 'drizzle-orm/sqlite-core';

// Candles table - OHLCV data cache
export const candles = sqliteTable('candles', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  symbol: text('symbol').notNull(),
  timeframe: text('timeframe').notNull(),
  timestamp: integer('timestamp').notNull(),
  open: real('open').notNull(),
  high: real('high').notNull(),
  low: real('low').notNull(),
  close: real('close').notNull(),
  volume: real('volume').notNull(),
});

// Trades table - Trading journal
export const trades = sqliteTable('trades', {
  id: text('id').primaryKey(),
  symbol: text('symbol').notNull(),
  timeframe: text('timeframe').notNull(),
  direction: text('direction').notNull(), // 'long' | 'short'
  status: text('status').notNull(), // 'open' | 'closed' | 'cancelled'
  outcome: text('outcome').notNull(), // 'win' | 'loss' | 'breakeven' | 'pending'

  entryTime: integer('entry_time', { mode: 'timestamp' }).notNull(),
  exitTime: integer('exit_time', { mode: 'timestamp' }),

  entryPrice: real('entry_price').notNull(),
  stopLoss: real('stop_loss').notNull(),
  takeProfit: real('take_profit').notNull(),
  exitPrice: real('exit_price'),

  riskAmount: real('risk_amount').notNull(),
  riskPercent: real('risk_percent').notNull(),
  plannedRR: real('planned_rr').notNull(),
  actualRR: real('actual_rr'),

  pnl: real('pnl'),
  pnlPercent: real('pnl_percent'),

  htfBias: text('htf_bias').notNull(), // 'bullish' | 'bearish' | 'neutral'
  setupType: text('setup_type').notNull(),
  killZone: text('kill_zone'),

  entryReason: text('entry_reason').notNull(),
  exitReason: text('exit_reason'),
  notes: text('notes'),
  screenshots: text('screenshots'), // JSON array

  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
});

// ICT Rules - User-defined trading rules from video transcripts
export const ictRules = sqliteTable('ict_rules', {
  id: text('id').primaryKey(), // UUID
  name: text('name').notNull(),
  description: text('description'),

  // Source tracking
  source: text('source'), // "2022 Mentorship EP 15"
  sourceUrl: text('source_url'), // YouTube URL
  sourceTimestamp: text('source_timestamp'), // "24:30"

  // Rule configuration (JSON strings for flexibility)
  conditions: text('conditions').notNull(), // JSON: RuleCondition[]
  entryLogic: text('entry_logic').notNull(), // JSON: EntryRule
  exitLogic: text('exit_logic').notNull(), // JSON: ExitRule

  // Categorization
  concepts: text('concepts'), // JSON array: ['fvg', 'ob', 'liquidity']
  killZones: text('kill_zones'), // JSON array: ['ny_am', 'london']
  direction: text('direction'), // 'long' | 'short' | 'both'

  // Status
  isActive: integer('is_active', { mode: 'boolean' }).notNull().default(true),
  confidence: text('confidence').notNull().default('learning'), // 'learning' | 'testing' | 'proven'

  // Performance tracking
  totalTriggers: integer('total_triggers').notNull().default(0),
  approvedTrades: integer('approved_trades').notNull().default(0),
  wins: integer('wins').notNull().default(0),
  losses: integer('losses').notNull().default(0),

  // User notes
  notes: text('notes'),

  // Timestamps
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull(),
});

// Trade suggestions - Generated by rule engine
export const tradeSuggestions = sqliteTable('trade_suggestions', {
  id: text('id').primaryKey(),
  ruleId: text('rule_id').notNull(),

  // Trade details
  symbol: text('symbol').notNull(),
  direction: text('direction').notNull(), // 'long' | 'short'
  entryPrice: real('entry_price').notNull(),
  stopLoss: real('stop_loss').notNull(),
  takeProfit: real('take_profit').notNull(),
  riskReward: real('risk_reward').notNull(),

  // Context
  htfBias: text('htf_bias'), // 'bullish' | 'bearish'
  killZone: text('kill_zone'),
  confluenceScore: integer('confluence_score'),
  reasoning: text('reasoning'), // Why this setup triggered

  // Status
  status: text('status').notNull().default('pending'), // 'pending' | 'approved' | 'rejected' | 'expired'

  // Outcome (if approved and closed)
  outcome: text('outcome'), // 'win' | 'loss' | 'breakeven'
  exitPrice: real('exit_price'),
  pnlR: real('pnl_r'),

  // Timestamps
  triggeredAt: integer('triggered_at', { mode: 'timestamp' }).notNull(),
  respondedAt: integer('responded_at', { mode: 'timestamp' }),
  closedAt: integer('closed_at', { mode: 'timestamp' }),
});

// Setup fingerprints - For intelligence system
export const setupFingerprints = sqliteTable('setup_fingerprints', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  signature: text('signature').unique().notNull(),
  bias: text('bias').notNull(),
  direction: text('direction').notNull(),
  hasLiquiditySweep: integer('has_liquidity_sweep', { mode: 'boolean' }).notNull(),
  hasChoch: integer('has_choch', { mode: 'boolean' }).notNull(),
  hasOrderBlock: integer('has_order_block', { mode: 'boolean' }).notNull(),
  hasFVG: integer('has_fvg', { mode: 'boolean' }).notNull(),
  inOTE: integer('in_ote', { mode: 'boolean' }).notNull(),
  inKillZone: integer('in_kill_zone', { mode: 'boolean' }).notNull(),
  rrBucket: text('rr_bucket').notNull(), // '1-2', '2-3', '3+'
  confluenceCount: integer('confluence_count').notNull(),
  totalTrades: integer('total_trades').notNull().default(0),
  wins: integer('wins').notNull().default(0),
  losses: integer('losses').notNull().default(0),
  totalPnlR: real('total_pnl_r').notNull().default(0),
});

// Setup records - Individual setup instances
export const setupRecords = sqliteTable('setup_records', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  signature: text('signature').notNull(),
  symbol: text('symbol').notNull(),
  timeframe: text('timeframe').notNull(),
  timestamp: integer('timestamp').notNull(),
  entryPrice: real('entry_price').notNull(),
  stopLoss: real('stop_loss').notNull(),
  takeProfit: real('take_profit').notNull(),
  exitPrice: real('exit_price'),
  outcome: text('outcome').notNull(), // 'win' | 'loss' | 'pending'
  pnlR: real('pnl_r'), // R-multiple return
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
});

// ============================================================================
// KNOWLEDGE BASE TABLES
// ============================================================================

// Video sources - Track YouTube videos and processing status
export const videoSources = sqliteTable('video_sources', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  videoId: text('video_id').notNull().unique(),
  title: text('title'),
  channelName: text('channel_name'),
  playlistId: text('playlist_id'),
  playlistName: text('playlist_name'),
  duration: integer('duration'), // seconds
  publishedAt: integer('published_at', { mode: 'timestamp' }),
  status: text('status').notNull().default('pending'), // 'pending' | 'transcribed' | 'processed' | 'error'
  errorMessage: text('error_message'),
  transcriptPath: text('transcript_path'),
  processedAt: integer('processed_at', { mode: 'timestamp' }),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
});

// Knowledge chunks - Processed content for vector search
export const knowledgeChunks = sqliteTable('knowledge_chunks', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  content: text('content').notNull(),
  sourceType: text('source_type').notNull(), // 'youtube' | 'notion' | 'manual'
  sourceUrl: text('source_url'),
  videoId: text('video_id'),
  timestamp: text('timestamp'), // "12:34"
  concept: text('concept'), // 'order-blocks', 'fvg', 'market-structure', etc.
  section: text('section'), // H2 header from markdown
  filePath: text('file_path'), // Link to markdown file
  embedding: text('embedding'), // JSON array of floats (768-dim)
  tokenCount: integer('token_count'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
});

// Flashcards with FSRS spaced repetition
export const flashcards = sqliteTable('flashcards', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  chunkId: integer('chunk_id').references(() => knowledgeChunks.id),
  type: text('type').notNull(), // 'basic' | 'cloze' | 'sequence'
  front: text('front').notNull(),
  back: text('back').notNull(),
  tags: text('tags'), // JSON array
  // FSRS fields for spaced repetition
  state: text('state').notNull().default('new'), // 'new' | 'learning' | 'review' | 'relearning'
  difficulty: real('difficulty').default(0),
  stability: real('stability').default(0),
  due: integer('due', { mode: 'timestamp' }),
  lastReview: integer('last_review', { mode: 'timestamp' }),
  reps: integer('reps').default(0),
  lapses: integer('lapses').default(0),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
});

// ICT Concepts - Master list of concepts for categorization
export const ictConcepts = sqliteTable('ict_concepts', {
  id: text('id').primaryKey(), // slug: 'order-blocks', 'fair-value-gaps'
  name: text('name').notNull(), // Display name
  category: text('category').notNull(), // 'market-structure' | 'liquidity' | 'time' | 'entry-models'
  description: text('description'),
  dependencies: text('dependencies'), // JSON array of concept IDs that must be learned first
  phase: integer('phase'), // Learning phase from roadmap (1-7)
});

// ============================================================================
// PAPER TRADING TABLES
// ============================================================================

// Paper trading sessions
export const paperSessions = sqliteTable('paper_sessions', {
  id: text('id').primaryKey(),
  symbol: text('symbol').notNull(),
  timeframe: text('timeframe').notNull(),
  modelPath: text('model_path').notNull(),
  config: text('config').notNull(), // JSON: PaperTraderConfig

  // Stats
  totalTrades: integer('total_trades').default(0),
  wins: integer('wins').default(0),
  losses: integer('losses').default(0),
  totalPnl: real('total_pnl').default(0),
  totalPnlPercent: real('total_pnl_percent').default(0),
  maxDrawdown: real('max_drawdown').default(0),
  sharpe: real('sharpe').default(0),

  // Timing
  startedAt: integer('started_at', { mode: 'timestamp' }).notNull(),
  endedAt: integer('ended_at', { mode: 'timestamp' }),
  uptimeSeconds: integer('uptime_seconds').default(0),
  isActive: integer('is_active', { mode: 'boolean' }).default(true),
});

// Paper trades
export const paperTrades = sqliteTable('paper_trades', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  tradeId: text('trade_id').notNull().unique(), // UUID for cross-reference
  sessionId: text('session_id').notNull(),
  symbol: text('symbol').notNull(),
  timeframe: text('timeframe').notNull(),

  // Position
  side: text('side').notNull(), // 'long' | 'short'
  status: text('status').notNull(), // 'open' | 'closed'
  entryPrice: real('entry_price').notNull(),
  exitPrice: real('exit_price'),
  stopLoss: real('stop_loss').notNull(),
  takeProfit: real('take_profit').notNull(),

  // Timing
  entryTime: integer('entry_time', { mode: 'timestamp' }).notNull(),
  exitTime: integer('exit_time', { mode: 'timestamp' }),
  entryIndex: integer('entry_index').notNull(),
  exitIndex: integer('exit_index'),
  barsHeld: integer('bars_held'),

  // Agent decision
  entryConfluence: integer('entry_confluence'),
  entryFactors: text('entry_factors'), // JSON array
  exitAction: text('exit_action'), // 'hold' | 'exit_market' | 'tighten_stop' | 'take_partial'
  exitReason: text('exit_reason'), // 'agent' | 'stop_loss' | 'take_profit' | 'max_bars' | 'shutdown'

  // Performance
  pnl: real('pnl'),
  pnlPercent: real('pnl_percent'),

  // KB context
  kbPrimaryConcept: text('kb_primary_concept'),
  kbAlignmentScore: real('kb_alignment_score'),

  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
});

// ============================================================================
// TYPE EXPORTS
// ============================================================================

// Trading types
export type CandleRow = typeof candles.$inferSelect;
export type NewCandleRow = typeof candles.$inferInsert;
export type TradeRow = typeof trades.$inferSelect;
export type NewTradeRow = typeof trades.$inferInsert;
export type SetupFingerprintRow = typeof setupFingerprints.$inferSelect;
export type SetupRecordRow = typeof setupRecords.$inferSelect;

// ICT Rules types
export type ICTRuleRow = typeof ictRules.$inferSelect;
export type NewICTRuleRow = typeof ictRules.$inferInsert;
export type TradeSuggestionRow = typeof tradeSuggestions.$inferSelect;
export type NewTradeSuggestionRow = typeof tradeSuggestions.$inferInsert;

// Knowledge base types
export type VideoSourceRow = typeof videoSources.$inferSelect;
export type NewVideoSourceRow = typeof videoSources.$inferInsert;
export type KnowledgeChunkRow = typeof knowledgeChunks.$inferSelect;
export type NewKnowledgeChunkRow = typeof knowledgeChunks.$inferInsert;
export type FlashcardRow = typeof flashcards.$inferSelect;
export type NewFlashcardRow = typeof flashcards.$inferInsert;
export type ICTConceptRow = typeof ictConcepts.$inferSelect;
export type NewICTConceptRow = typeof ictConcepts.$inferInsert;

// Paper trading types
export type PaperSessionRow = typeof paperSessions.$inferSelect;
export type NewPaperSessionRow = typeof paperSessions.$inferInsert;
export type PaperTradeRow = typeof paperTrades.$inferSelect;
export type NewPaperTradeRow = typeof paperTrades.$inferInsert;
